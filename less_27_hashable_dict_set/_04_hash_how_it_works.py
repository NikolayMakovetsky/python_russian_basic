"""
КАК РАБОТАЕТ HASH ?

ПРИ СОЗДАНИИ СЛОВАРЯ ПОД КАПОТОМ БУДЕТ СОЗДАНО 8 ЕЛЕМЕНТОВ (МАССИВ ЯЧЕЕК)

Словарю необходим массив в памяти, с которым он будет работать
При записи пары ключ-значение в словарь
для каждого КЛЮЧА вычисляется hash и ПО ФОРМУЛЕ(см.книги) в зависимости от полученного hash,
мы получаем определенный ИНДЕКС, и по этому ИНДЕКСУ в массив ЗАПИСЫВАЕТСЯ И КЛЮЧ, И ЗНАЧЕНИЕ!
Когда массив будет заполнен на 2/3, то происзодит увеличение памяти и перехеширование всех ключей
Все хеши завязаны на длину выделенного массива.
Внутри одной ячейки массива мб ТОЛЬКО ОДНА ПАРА ключ-значение (ОДИН ОБЪЕКТ)

Секрет быстрого поиска по хешам:
По ключу ОПЯТЬ ЖЕ ПО ФОРМУЛЕ вычисляется индекс (ЧТО ЗАНИМАЕТ ФИКСИРОВАННОЕ ВРЕМЯ),
по индексу ОДНОЗНАЧНО находится ячейка в массиве, в которой хранится и ключ и значение
Далее, ИЗ-ЗА ВОЗМОЖНЫХ КОЛЛИЗИЙ(см. ниже),
дополнительно происходит проверка ключа на соответствие.
Если ключ совпадает, то возвращается значение. ЭТО РАБОТАЕТ БЫСТРО!

КОЛЛИЗИИ
Для встроенных данных это маловероятно
Это скорее относится к объектам пользовательских классов...
Если у 2-х неравных элементов хэш одинаковый, то что же делать питону?
Если питон вычислил ИНДЕКС ПО ФОРМУЛЕ, а в этой ячейке уже лежит объект,
он проверяет ключи на соответствие.
Если ключи совпадают, то он перезпишет значение
ЕСЛИ КЛЮЧИ НЕ СОВПАДАЮТ, ТО ПО СПЕЦИАЛЬНОЙ ФОРМУЛЕ ДЛЯ КОЛЛИЗИЙ
питон вычислит новый индекс и попытается записать пару ключ-значение туда.
Если и там произойдет коллизия, он вычислит новый индекс, и так до тех пор,
пока не найдется свободная ячейка в массиве.
ПОИСК ЭЛЕМЕНТА тоже будет осуществляться по этому же принципу...
Питон сначала придет в ячейку где уже есть что-то, сравнит ключи, потом
вычислит новый индекс, там сравнит ключи...ну и так далее


ЧИТАЙ ДОКУМЕНТАЦИЮ:
* БАЗОВАЯ ФОРМУЛА ПОЛУЧЕНИЯ ИНДЕКСА(ХЭША)
* ФОРМУЛА ПОЛУЧЕНИЯ ИНДЕКСА ПРИ КОЛЛИЗИИ

"""

class Cat:
    pass


if __name__ == '__main__':
    print("\n--- Для пользовательских объектов hash = id // 16")
    tom = Cat()
    print(hash(tom))  # хеш объекта
    print(id(tom))  # адрес в памяти, где лежит объект
    print(id(tom)//16)