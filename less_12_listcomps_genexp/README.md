## listcomps and genexp

List comprehension = listcomps
Generator expressions = genexp

### Состав listcomps and genexp
[ВЫРАЖЕНИЕ/ПРЕОБРАЗОВАНИЕ for element in ИСТОЧНИК if УСЛОВИЕ]

### Как это работает?
1. Возьми элемент из какого-то источкика
2. Проверь соответствует ли он условию (не обязательно)
3. Выполни действие над элементом

Переменные внутри listcomps/genexp доступны только внутри этих выражений

### Результат listcomps всегда коллекция:
list, set, dict

## Плюсы и минусы listcomps
- [+] Читаемость
- [+] Мы сразу получаем данные
- [-] Память занимается сразу вся

## genexp

- Не формирует какую-то структуру данных
- Он формирует объект генератора

genexp возвращает объект-генератор, который
ленивый и в данный момент не выполняет никаких операций
и не выделяет никакой памяти.

"Ленивый" - термин, кот означает что любая работа
откладывается как можно дальше

Генератор - это набор инструкций, как именно 
ему нужно формировать новое значение

Генератор можно "прогнать" ТОЛЬКО ОДИН РАЗ!
Далее он будет кидать StopIteration, которое
мы не увидим если используем цикл.
(цикл for перехватывает исключение StopIteration)

## Плюсы и минусы genexp
- [+] "Ленивый" -> память не занимается
- [+] Он намного быстрее listcomps
- [-] Его можно использовать только ОДИН РАЗ
- [-] Он проверяет свой источник. Это может 
быть проблемой если функция-источник очень громоздкая.

### Что лучше использовать? listcomps или genexp?
Как можно чаще используй genexp

Про genexp часто забывают, но вспоминают, когда
нужно прочитать файл, в котором 16 ГБ логов =)

Задача: Нужна длина списка, но его длина 20ГБ
Естественно вы не будете использовать listcomps,
вы будете использовать genexp, но будете придумывать
переменную, которая будет подсчитывать ваши ошибки в логах,
т.к. иначе это займет слишком много памяти.

