## Отладчик

Наши программы большую часть времени не работают,
поэтому нам приходится достаточно большое кол-во
времени тратить на работу с отладчиком!

### Отладка принтами

Способ для начинающих.
Минус в том, что принты нужно писать, 
и притом не совсем понятно где именно они нужны.
А после завершения процесса отладки все принты
нужно удалять, что также неудобно

### Настройка debugger

```
Run -> View breakpoints
settings:
v - Python Exception Breakpoint
v - Any Exception

Any Exception settings:
v - Enabled (включен)
v - Suspend execution (приостановить выполнение)
```
### Начало работы без breakpoint-ов

Просто запускаем файл в режиме отладки.
Если есть исключения, то дебаггер нам их покажет,
также выдаст имя исключения и значение,
которое имеет переменная у строке, содержащей ошибку

### Ставим breakpoint только когда проблема уже найдена

### Удобство Debugger MainThread (стек вызовов)

Появляется в слева в окне дебаггера.
Там указывается порядок вызовов всех функций
до возникновения ошибки, т.е. мы можем легко
отследить историю, что именно запускалось
и в каком порядке

Это также ВАЖНО, поскольку бывает что мы понимаем
в чем именно ошибка (в каком месте и какая именно),
но мы не понимаем откуда пришли данные,
вызвавшие ошибку...

MainThread позволяет быстро понять откуда
приходят значения переменных

### Debug Evaluate Expression...Alt + F8 (значок калькулятора)

Выполнитель выражений
```
Code fragment:
result.count("?")

Result:
result = {int} 0
```

```
Code fragment:
result.count("!")

Result:
result = {int} 2
```

Evaluate позволяет делать вычисления в
любой точке программы, вручную менять значения
переменных в конкретной точке программы и 
смотреть какой будет результат.

Более того, мы можем даже присвоить конерктной 
переменной в данной точке программы нужное значение
(чтобы проскочить ошибку) и продолжить выполнение.
Это может нам дать информацию о том, исправится
ли ошибка полностью, если в функцию
будет передаваться указанное вручную значение,
или при таком раскладе программа выдаст другие
ошибки ниже.

Evaluate (Вычислитель) знает значения всех переменных в том scope,
в котором сейчас находится дебаггер.

Evaluate (Вычислитель) - это отдельный интерпретатор,
и в нем мы можем сделать всё что нам нужно.
Мы можем сделать импорт модуля, которого вообще
не было в нашей программе...и с его помощью сделать
необходимые нам вычисления с некой переменной
или сделать какую-то проверку...
```
import sys
```
```
sys.getsizeof(result) -> 52 (байта)
```
### Перезапуск дебаггера

Пока вы не перезапустили дебаггер, 
ваши изменения в коде ему не видны!

### Работа с консолью при отладке

В процессе отладки, может потребоваться 
работа с консолью (например, программа может
запрашивать значения с клавиатуры)

Чтобы осуществить ввод, не выходя из режима отладки,
необходимо в дебаггере открыть специальную вкладку,
которая так и называется "Console"


### Debugger settings -> Show Return Values

"Показывать возвращаемые значения функций"

Полезная настройка.
Иногда очень удобно посмотреть, а что конкретно
функция возвращает.
Т.к. без данной настройки, дебаггер показывает нам
только текущие значения переменных, но что конкретно
та или иная ф-я возвращает нам неизвестно.

```
(v) Return Values
    three() = {NoneType} None
```

### Debugger Watches (отслеживание)

Удобно при работе с циклом.
По длинному циклу перемещаться пошагово
неудобно и нерационально.

### Resume program |>

Продолжит выполнение программы до следующего
исключения, либо до следующего breakpoint-а


### Использование Watches + Resume program |>

Если поставить breakpoint на начало цикла:
```
[КРУЖОК] for e in range(6):
```
то нажимая кнопку "Resume program |>"
можно быстро перемещаться на следующую итерацию,
а добавление нужных переменных в Watches
позволит сконцентрировать свое внимание
именно на них.

(Если мы отлаживаем сложную функцию, то
в общем потоке "Threads & Variables"
может быть избыток информации
о разных переменных, а
Watches позволит отслеживать конкретные,
нужные нам переменные)
